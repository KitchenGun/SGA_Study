#pragma once
#include "../Global/Define/KGDefine.h"
/*
c++ 11 버전이란?
프로그래밍 언어는 처음 탄생했을때 지니고 있는 기능를 계속 유지하는 것이 아니라 기술이 발전되고 니드 사항이 변화함에 따라
프로그래밍 언어도 기능이 추가 되고 변경이 발생한다
즉 지속적으로 관리 되고 유지된다 c++언어 또한 기존에 비해 현대적인 기술이 반영해서
발전을 이루었으며 c++11 버전부터 해당 현상이 두드러진다 즉 c++11버전 이상부터는
모던 c++이라고 지칭하며 현대 언어가 지니고 있는 많은 유용한 기능을 지원한다

c++11 버전 주요 특징
-auto 키워드 지원 
-범위기반 for문 지원 순회문
-스마트 포인터 지원 
-람다 지원


스마트 포인터란?
-포인터 처럼 동작하는 객체를 의미하며 스마트포인터를 사용하면 내부적인 규칙에 따라 동적으로 할당된 메모리를 스스로 관리해주는 기능을 지고있습니다
즉 스마트 포인터를 활용하면 특정 메모리의 삭제 시기를 고민하지 않고 프로그램을 작성하는 것이 가능하다

C++언어 스마트 포인터의 종류
auto_ptr	귄한 위임 방식
unique_ptr	권한 위임 방식
shared_ptr	레퍼런스 카운팅 방식
weak_ptr	shared_ptr의 순환 참조를 방지하기 위해 사용되는 포인터

위의 스마트 포인터중 auto_ptr은 c++11버전 이전부터 존재해온 포인터이며 
unique_ptr 과 shared_ptr c++11버전 부터 추가된 새로운 스마트 포인터이다.
weak_ptr은 단독 사용은 불가능하며 shared ptr의 보조하기 위한 역할로 사용된다
이는 shared_ptr의 단점은 순환 참조 구조가 발생했을 경우 메모리 릭이 발생할 수 있기 때문에 이를 방지하기위해서 사용되는 것이 weak_ptr이다 

권한 위임 방식이란? 
특정 메모리에 접근하는 포인터를 한번에 하나로 제한 함으로써 해당 메모리의 삭제 권한을 
마지막으로 가리키고 있는 포인터에게 위임하는 방식으로 메모리를 관리하는 것을 의미한다
즉 특정 메모리를 공유하지 않고 한개씩 접근을 허용함으로써 메모리의 삭제 시기를 결정하는 방법을 의미한다
권한위임방식은 특정메모리 공유 방식이 불가능하다

레퍼런스 카운딩 방식이란?
특정 메모리에 접근하고있는 포인터의 개수를 내부적으로 카운팅하고있다가 더이상 
참조하고 있는 포인터가 존재하지 않을 경우 스스로 메모리 해제하는 방식으로 관리하는 메모리 관리 기법을 의미한다 
따라서 레퍼런스 카운팅 방식은 특정 메모리를 서로 공유해서 작업을 수행하는 것이 가능하다

람다란?
클로저라고 하며 해당 기능을 사용하면 특정 함수에 내부에 지역함수를 선언 및 구현하는 것이 가능하다 
즉 람다는 특정지역에서만 사용하고 재사용되지 않는 일회성 함수를 만들어 내는 것이 가능하다

c++ 람다 선언 방법
캡쳐절 + 매개 변수 절 + 람다 몸체
외부의 모든 변수를 참조하고 싶으면 캡쳐절을 [&]로 기입하고
외부의 모든 변수를 값형식으로 불러오고 싶으면 캡쳐절을 [=]로 기입하면된다.
만약 외부에 존재하는 모든 변수를 값 또는 참조형식으로 하다가 특정 변수의 캡쳐 방식을 바꾸고 싶으면 [=,&nLhs,&nRhs],[&,nLhs,nRhs]이렇게 기입하면 된다
ex 
auto oLambda=[](int a_nLhs,inta_nRhs)
{
	printf("%d + %d =%d\n",a_nLhs,a_nRhs,a_nLhs+a_nRhs);
};

oLambda(10,20);
*/
namespace E08Space
{
	void E08(const int argc, const char **args);
}